The idea is to use the linux tracing system to enhance my control of the
system.

1. Use /sys/kernel/debug/tracing/events/sched/sched_process_exec to trace
running of new executables. I can use /proc/xxx/cmdline to print the
cmdline.

trace_sched_process_exec.py

2. Use sched/* to trace the time spent in different state for one process.
sched_process_exec, when the elf file is loaded.
sched_process_exit, when the process do_exit.
sched_process_fork, when new process is forked. (you may need to continue
monitor the child processes)
sched_process_free, when the task_struct is freed. Doesn't matter.
sched_process_hang, when one task wait for too long? Doesn't matter.
sched_process_wait, when the user space requests to waitpid/wait4? So
I think it doesn't matter.
sched_stat_iowait, wait for io?
sched_stat_blocked,  ?
sched_stat_runtime, time for running
sched_stat_sleep, time for sleep
sched_stat_wait, time waiting on the runqueue?
sched_switch, whenever sched_switch happens.
sched_wakeup, when a task is wakeup
sched_wait_task, wait for one task to unscheduled.
sched_wakeup_new, wakeup a newly created task.

trace_sched_process_runtime.py
trace_sched_process_sleep.py
trace_sched_process_wait.py
trace_sched_process_block.py

3. Use syscalls/* events to distinguish the user space execution time and the kernel space
execution time. I can use context_switch to calculate the process time. Then user space time
is generated by subtracting the kernel space time from the process time.

trace_process_user_kernel.py

The function of 2 and 3 are merged into trace_sched_process_stat.py.
